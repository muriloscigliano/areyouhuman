---
interface Props {
  text?: string;
  fontSize?: number;
  fontFamily?: string;
  isBold?: boolean;
  color?: { r: number; g: number; b: number };
  bgColor?: { r: number; g: number; b: number };
  class?: string;
}

const {
  text = "ARE YOU HUMAN?",
  fontSize = 80,
  fontFamily = "PP Neue Machina",
  isBold = true,
  color = { r: 0, g: 0, b: 0 }, // Black shader
  bgColor = { r: 1, g: 1, b: 1 }, // White background
  class: className = ""
} = Astro.props;
---

<div class={`fluid-text-container ${className}`} data-fluid-text data-text={text} data-font-size={fontSize} data-font-family={fontFamily} data-is-bold={isBold} data-color-r={color.r} data-color-g={color.g} data-color-b={color.b} data-bg-r={bgColor.r} data-bg-g={bgColor.g} data-bg-b={bgColor.b}>
  <canvas class="fluid-canvas"></canvas>
</div>

<script>
  // Vertex Shader
  const vertShaderSource = `
    precision highp float;
    varying vec2 vUv;
    attribute vec2 a_position;
    varying vec2 vL;
    varying vec2 vR;
    varying vec2 vT;
    varying vec2 vB;
    uniform vec2 u_texel;

    void main () {
        vUv = .5 * (a_position + 1.);
        vL = vUv - vec2(u_texel.x, 0.);
        vR = vUv + vec2(u_texel.x, 0.);
        vT = vUv + vec2(0., u_texel.y);
        vB = vUv - vec2(0., u_texel.y);
        gl_Position = vec4(a_position, 0., 1.);
    }
  `;

  // Fragment Shaders
  const fragShaderAdvection = `
    precision highp float;
    precision highp sampler2D;
    varying vec2 vUv;
    uniform sampler2D u_velocity_texture;
    uniform sampler2D u_input_texture;
    uniform vec2 u_texel;
    uniform float u_dt;
    uniform float u_use_text;
    uniform sampler2D u_text_texture;

    vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {
        vec2 st = uv / tsize - 0.5;
        vec2 iuv = floor(st);
        vec2 fuv = fract(st);
        vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);
        vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);
        vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);
        vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);
        return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);
    }

    void main () {
        vec2 coord = vUv - u_dt * bilerp(u_velocity_texture, vUv, u_texel).xy * u_texel;
        float text = texture2D(u_text_texture, vec2(vUv.x, 1. - vUv.y)).r;
        float dissipation = (.96 + text * .04 * u_use_text);
        gl_FragColor = dissipation * bilerp(u_input_texture, coord, u_texel);
        gl_FragColor.a = 1.;
    }
  `;

  const fragShaderDivergence = `
    precision highp float;
    precision highp sampler2D;
    varying highp vec2 vUv;
    varying highp vec2 vL;
    varying highp vec2 vR;
    varying highp vec2 vT;
    varying highp vec2 vB;
    uniform sampler2D u_velocity_texture;

    void main () {
        float L = texture2D(u_velocity_texture, vL).x;
        float R = texture2D(u_velocity_texture, vR).x;
        float T = texture2D(u_velocity_texture, vT).y;
        float B = texture2D(u_velocity_texture, vB).y;
        float div = .6 * (R - L + T - B);
        gl_FragColor = vec4(div, 0., 0., 1.);
    }
  `;

  const fragShaderPressure = `
    precision highp float;
    precision highp sampler2D;
    varying highp vec2 vUv;
    varying highp vec2 vL;
    varying highp vec2 vR;
    varying highp vec2 vT;
    varying highp vec2 vB;
    uniform sampler2D u_pressure_texture;
    uniform sampler2D u_divergence_texture;
    uniform sampler2D u_text_texture;

    void main () {
        float text = texture2D(u_text_texture, vec2(vUv.x, 1. - vUv.y)).r;
        float L = texture2D(u_pressure_texture, vL).x;
        float R = texture2D(u_pressure_texture, vR).x;
        float T = texture2D(u_pressure_texture, vT).x;
        float B = texture2D(u_pressure_texture, vB).x;
        float divergence = texture2D(u_divergence_texture, vUv).x;
        float pressure = (L + R + B + T - divergence) * 0.25;
        pressure += (.2 * text);
        gl_FragColor = vec4(pressure, 0., 0., 1.);
    }
  `;

  const fragShaderGradientSubtract = `
    precision highp float;
    precision highp sampler2D;
    varying highp vec2 vUv;
    varying highp vec2 vL;
    varying highp vec2 vR;
    varying highp vec2 vT;
    varying highp vec2 vB;
    uniform sampler2D u_pressure_texture;
    uniform sampler2D u_velocity_texture;

    void main () {
        float L = texture2D(u_pressure_texture, vL).x;
        float R = texture2D(u_pressure_texture, vR).x;
        float T = texture2D(u_pressure_texture, vT).x;
        float B = texture2D(u_pressure_texture, vB).x;
        vec2 velocity = texture2D(u_velocity_texture, vUv).xy;
        velocity.xy -= vec2(R - L, T - B);
        gl_FragColor = vec4(velocity, 0., 1.);
    }
  `;

  const fragShaderPoint = `
    precision highp float;
    precision highp sampler2D;
    varying vec2 vUv;
    uniform sampler2D u_input_texture;
    uniform float u_ratio;
    uniform vec3 u_point_value;
    uniform vec2 u_point;
    uniform float u_point_size;
    uniform sampler2D u_text_texture;

    void main () {
        vec2 p = vUv - u_point.xy;
        p.x *= u_ratio;
        vec3 splat = pow(2., -dot(p, p) / u_point_size) * u_point_value;
        float text = texture2D(u_text_texture, vec2(vUv.x, 1. - vUv.y)).r;
        splat *= (.7 + .2 * text);
        vec3 base = texture2D(u_input_texture, vUv).xyz;
        gl_FragColor = vec4(base + splat, 1.);
    }
  `;

  const fragShaderOutput = `
    precision highp float;
    precision highp sampler2D;
    varying vec2 vUv;
    uniform sampler2D u_output_texture;
    uniform sampler2D u_text_texture;
    uniform vec3 u_bg_color;

    void main () {
        vec3 C = texture2D(u_output_texture, vUv).rgb;
        float text = texture2D(u_text_texture, vec2(vUv.x, 1. - vUv.y)).r;
        // White background with black fluid effect
        gl_FragColor = vec4(u_bg_color - C, 1.);
    }
  `;

  class FluidSimulation {
    private canvas: HTMLCanvasElement;
    private textureCanvas: HTMLCanvasElement;
    private textureCtx: CanvasRenderingContext2D | null = null;
    private gl: WebGLRenderingContext | null = null;
    private params: {
      text: string;
      fontSize: number;
      fontFamily: string;
      isBold: boolean;
      color: { r: number; g: number; b: number };
      bgColor: { r: number; g: number; b: number };
      pointerSize: number;
    } = {
      text: 'ARE YOU HUMAN?',
      fontSize: 80,
      fontFamily: 'PP Neue Machina',
      isBold: true,
      color: { r: 0, g: 0, b: 0 },
      bgColor: { r: 1, g: 1, b: 1 },
      pointerSize: 0.003
    };
    private pointer = { x: 0, y: 0, dx: 0, dy: 0, moved: false };
    private isPreview = true;
    private animationId: number | null = null;
    private programs: any = {};
    private fbos: any = {};
    private canvasTexture: WebGLTexture | null = null;
    private isDestroyed = false;

    constructor(container: HTMLElement) {
      this.canvas = container.querySelector('.fluid-canvas') as HTMLCanvasElement;
      this.textureCanvas = document.createElement('canvas');

      // Get params from data attributes first (always safe to do)
      this.params = {
        text: container.dataset.text || 'ARE YOU HUMAN?',
        fontSize: parseInt(container.dataset.fontSize || '80'),
        fontFamily: container.dataset.fontFamily || 'PP Neue Machina',
        isBold: container.dataset.isBold === 'true',
        color: {
          r: parseFloat(container.dataset.colorR || '0'),
          g: parseFloat(container.dataset.colorG || '0'),
          b: parseFloat(container.dataset.colorB || '0')
        },
        bgColor: {
          r: parseFloat(container.dataset.bgR || '1'),
          g: parseFloat(container.dataset.bgG || '1'),
          b: parseFloat(container.dataset.bgB || '1')
        },
        pointerSize: 0.003
      };

      const ctx = this.textureCanvas.getContext('2d');
      if (!ctx) {
        console.error('FluidText: 2D context not supported');
        return;
      }
      this.textureCtx = ctx;

      const gl = this.canvas.getContext('webgl', {
        alpha: true,
        preserveDrawingBuffer: false,
        antialias: false
      });
      if (!gl) {
        console.error('FluidText: WebGL not supported');
        return;
      }
      this.gl = gl;

      // Check for float texture support
      const floatExt = gl.getExtension('OES_texture_float');
      if (!floatExt) {
        console.warn('FluidText: OES_texture_float not supported, falling back');
      }

      // Wait for container to have proper dimensions before initializing
      this.waitForDimensions(container);
    }

    private waitForDimensions(container: HTMLElement) {
      const checkDimensions = () => {
        const rect = container.getBoundingClientRect();
        if (rect.width >= 50 && rect.height >= 50) {
          // Container has valid dimensions, initialize
          this.init();
        } else {
          // Keep checking until container has dimensions
          requestAnimationFrame(checkDimensions);
        }
      };
      requestAnimationFrame(checkDimensions);
    }

    private init() {
      if (!this.gl || !this.textureCtx) return;
      const gl = this.gl;

      // Set canvas dimensions FIRST before creating any FBOs
      const container = this.canvas.parentElement;
      if (!container) return;

      const rect = container.getBoundingClientRect();
      const width = Math.max(100, Math.floor(rect.width));
      const height = Math.max(100, Math.floor(rect.height));

      this.canvas.width = width;
      this.canvas.height = height;
      this.textureCanvas.width = width;
      this.textureCanvas.height = height;
      this.params.pointerSize = 4 / height;

      // Create shaders and programs
      const vertexShader = this.createShader(vertShaderSource, gl.VERTEX_SHADER);
      if (!vertexShader) return;

      this.programs.splat = this.createProgram(vertexShader, fragShaderPoint);
      this.programs.divergence = this.createProgram(vertexShader, fragShaderDivergence);
      this.programs.pressure = this.createProgram(vertexShader, fragShaderPressure);
      this.programs.gradientSubtract = this.createProgram(vertexShader, fragShaderGradientSubtract);
      this.programs.advection = this.createProgram(vertexShader, fragShaderAdvection);
      this.programs.output = this.createProgram(vertexShader, fragShaderOutput);

      // Setup buffers
      gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW);
      gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(0);

      this.createTextCanvasTexture();
      this.initFBOs();
      this.updateTextCanvas();
      this.setupEvents();

      window.addEventListener('resize', this.handleResize);
      this.render(0);
    }

    private handleResize = () => {
      this.resizeCanvas();
    };

    private createShader(source: string, type: number): WebGLShader | null {
      if (!this.gl) return null;
      const gl = this.gl;
      const shader = gl.createShader(type);
      if (!shader) return null;

      gl.shaderSource(shader, source);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader compile error:', gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    private createProgram(vertexShader: WebGLShader, fragmentSource: string) {
      if (!this.gl) return null;
      const gl = this.gl;
      const fragmentShader = this.createShader(fragmentSource, gl.FRAGMENT_SHADER);
      if (!fragmentShader) return null;

      const program = gl.createProgram();
      if (!program) return null;

      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program link error:', gl.getProgramInfoLog(program));
        return null;
      }

      const uniforms: Record<string, WebGLUniformLocation | null> = {};
      const uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
      for (let i = 0; i < uniformCount; i++) {
        const info = gl.getActiveUniform(program, i);
        if (info) {
          uniforms[info.name] = gl.getUniformLocation(program, info.name);
        }
      }

      return { program, uniforms };
    }

    private createTextCanvasTexture() {
      if (!this.gl) return;
      const gl = this.gl;
      this.canvasTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, this.canvasTexture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    }

    private updateTextCanvas() {
      if (!this.gl || !this.textureCtx) return;
      const ctx = this.textureCtx;
      const gl = this.gl;
      const { text, fontFamily, isBold } = this.params;

      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, this.textureCanvas.width, this.textureCanvas.height);

      ctx.fillStyle = '#ffffff';
      ctx.textAlign = 'center';
      ctx.filter = 'blur(3px)';

      // Support multiline text (split by newline)
      const lines = text.split('\n');
      const fontWeight = isBold ? '800' : 'normal';

      // Find the main lines (non-eyebrow) to calculate optimal size
      const mainLines = lines.filter((line, i) => {
        const isEyebrow = i === 0 && lines.length > 1 && !line.match(/^[A-Z\s?!]+$/);
        return !isEyebrow;
      });

      // Find the longest main line to base our size calculation on
      const longestMainLine = mainLines.reduce((a, b) => a.length > b.length ? a : b, '');

      // Calculate optimal font size to fit the canvas
      // Use 85% of canvas width as max text width, with padding
      const maxTextWidth = this.textureCanvas.width * 0.85;
      const maxTextHeight = this.textureCanvas.height * 0.7; // Leave room for eyebrow and spacing

      // Binary search for optimal font size
      let minSize = 20;
      let maxSize = this.textureCanvas.height * 0.5; // Start with half canvas height
      let optimalSize = minSize;

      while (minSize <= maxSize) {
        const testSize = Math.floor((minSize + maxSize) / 2);
        ctx.font = `${fontWeight} ${testSize}px "${fontFamily}", sans-serif`;

        // Measure the longest line
        const textWidth = ctx.measureText(longestMainLine).width;

        // Calculate total height for all main lines
        const lineHeight = testSize * 1.05;
        const totalMainHeight = mainLines.length * lineHeight;

        // Check if it fits
        if (textWidth <= maxTextWidth && totalMainHeight <= maxTextHeight) {
          optimalSize = testSize;
          minSize = testSize + 1;
        } else {
          maxSize = testSize - 1;
        }
      }

      const mainFontSize = optimalSize;

      // Calculate line heights - first line (eyebrow) is smaller
      const lineSizes: number[] = [];
      const lineHeights: number[] = [];

      lines.forEach((line, i) => {
        // First line is the eyebrow (smaller text)
        const isEyebrow = i === 0 && lines.length > 1 && !line.match(/^[A-Z\s?!]+$/);
        const size = isEyebrow ? mainFontSize * 0.18 : mainFontSize;
        lineSizes.push(size);
        lineHeights.push(size * (isEyebrow ? 2.5 : 1.05));
      });

      const totalHeight = lineHeights.reduce((a, b) => a + b, 0);
      let currentY = (this.textureCanvas.height - totalHeight) / 2;

      lines.forEach((line, i) => {
        const size = lineSizes[i];
        const isEyebrow = i === 0 && lines.length > 1 && !line.match(/^[A-Z\s?!]+$/);
        const weight = isEyebrow ? '600' : fontWeight;

        ctx.font = `${weight} ${size}px "${fontFamily}", sans-serif`;
        currentY += lineHeights[i];

        ctx.fillText(
          line,
          0.5 * this.textureCanvas.width,
          currentY - size * 0.2
        );
      });

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, this.canvasTexture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.textureCanvas);
    }

    private createFBO(w: number, h: number, type?: number): any {
      if (!this.gl) return null;
      const gl = this.gl;
      const glType = type !== undefined ? type : gl.RGBA;
      gl.activeTexture(gl.TEXTURE0);

      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texImage2D(gl.TEXTURE_2D, 0, glType, w, h, 0, glType, gl.FLOAT, null);

      const fbo = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
      gl.viewport(0, 0, w, h);
      gl.clear(gl.COLOR_BUFFER_BIT);

      return {
        fbo,
        width: w,
        height: h,
        attach: (id: number) => {
          gl.activeTexture(gl.TEXTURE0 + id);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          return id;
        }
      };
    }

    private createDoubleFBO(w: number, h: number, type?: number) {
      let fbo1 = this.createFBO(w, h, type);
      let fbo2 = this.createFBO(w, h, type);

      return {
        width: w,
        height: h,
        texelSizeX: 1 / w,
        texelSizeY: 1 / h,
        read: () => fbo1,
        write: () => fbo2,
        swap: () => {
          const temp = fbo1;
          fbo1 = fbo2;
          fbo2 = temp;
        }
      };
    }

    private initFBOs() {
      // Ensure minimum FBO size to prevent zero-size framebuffer errors
      const fboSize = [
        Math.max(50, Math.floor(0.5 * this.canvas.width)),
        Math.max(50, Math.floor(0.5 * this.canvas.height))
      ];

      this.fbos.outputColor = this.createDoubleFBO(fboSize[0], fboSize[1]);
      this.fbos.velocity = this.createDoubleFBO(fboSize[0], fboSize[1]);
      this.fbos.divergence = this.createFBO(fboSize[0], fboSize[1]);
      this.fbos.pressure = this.createDoubleFBO(fboSize[0], fboSize[1]);
    }

    private blit(target: any) {
      if (!this.gl) return;
      const gl = this.gl;
      if (target == null) {
        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      } else {
        gl.viewport(0, 0, target.width, target.height);
        gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);
      }
      gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
    }

    private render = (t: number) => {
      if (this.isDestroyed || !this.gl) return;

      const gl = this.gl;
      const dt = 1 / 60;
      const { velocity, outputColor, divergence, pressure } = this.fbos;
      const { splat, divergence: divProgram, pressure: pressProgram, gradientSubtract, advection, output } = this.programs;

      // No auto-animation - fluid only moves on user interaction

      if (this.pointer.moved) {
        this.pointer.moved = false;

        // Splat velocity
        gl.useProgram(splat.program);
        gl.uniform1i(splat.uniforms.u_input_texture, velocity.read().attach(1));
        gl.uniform1f(splat.uniforms.u_ratio, this.canvas.width / this.canvas.height);
        gl.uniform2f(splat.uniforms.u_point, this.pointer.x / this.canvas.width, 1 - this.pointer.y / this.canvas.height);
        gl.uniform3f(splat.uniforms.u_point_value, this.pointer.dx, -this.pointer.dy, 1);
        gl.uniform1f(splat.uniforms.u_point_size, this.params.pointerSize);
        this.blit(velocity.write());
        velocity.swap();

        // Splat color
        gl.uniform1i(splat.uniforms.u_input_texture, outputColor.read().attach(1));
        gl.uniform3f(splat.uniforms.u_point_value, 1 - this.params.color.r, 1 - this.params.color.g, 1 - this.params.color.b);
        this.blit(outputColor.write());
        outputColor.swap();
      }

      // Divergence
      gl.useProgram(divProgram.program);
      gl.uniform2f(divProgram.uniforms.u_texel, velocity.texelSizeX, velocity.texelSizeY);
      gl.uniform1i(divProgram.uniforms.u_velocity_texture, velocity.read().attach(1));
      this.blit(divergence);

      // Pressure
      gl.useProgram(pressProgram.program);
      gl.uniform2f(pressProgram.uniforms.u_texel, velocity.texelSizeX, velocity.texelSizeY);
      gl.uniform1i(pressProgram.uniforms.u_divergence_texture, divergence.attach(1));

      for (let i = 0; i < 10; i++) {
        gl.uniform1i(pressProgram.uniforms.u_pressure_texture, pressure.read().attach(2));
        this.blit(pressure.write());
        pressure.swap();
      }

      // Gradient subtract
      gl.useProgram(gradientSubtract.program);
      gl.uniform2f(gradientSubtract.uniforms.u_texel, velocity.texelSizeX, velocity.texelSizeY);
      gl.uniform1i(gradientSubtract.uniforms.u_pressure_texture, pressure.read().attach(1));
      gl.uniform1i(gradientSubtract.uniforms.u_velocity_texture, velocity.read().attach(2));
      this.blit(velocity.write());
      velocity.swap();

      // Advection velocity
      gl.useProgram(advection.program);
      gl.uniform1f(advection.uniforms.u_use_text, 0);
      gl.uniform2f(advection.uniforms.u_texel, velocity.texelSizeX, velocity.texelSizeY);
      gl.uniform1i(advection.uniforms.u_velocity_texture, velocity.read().attach(1));
      gl.uniform1i(advection.uniforms.u_input_texture, velocity.read().attach(1));
      gl.uniform1f(advection.uniforms.u_dt, dt);
      this.blit(velocity.write());
      velocity.swap();

      // Advection color
      gl.useProgram(advection.program);
      gl.uniform1f(advection.uniforms.u_use_text, 1);
      gl.uniform2f(advection.uniforms.u_texel, outputColor.texelSizeX, outputColor.texelSizeY);
      gl.uniform1i(advection.uniforms.u_input_texture, outputColor.read().attach(2));
      this.blit(outputColor.write());
      outputColor.swap();

      // Output
      gl.useProgram(output.program);
      gl.uniform1i(output.uniforms.u_output_texture, outputColor.read().attach(1));
      gl.uniform3f(output.uniforms.u_bg_color, this.params.bgColor.r, this.params.bgColor.g, this.params.bgColor.b);
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);

      this.animationId = requestAnimationFrame(this.render);
    };

    private resizeCanvas() {
      const container = this.canvas.parentElement;
      if (!container) return;

      const rect = container.getBoundingClientRect();

      // Ensure we have valid dimensions (minimum 1px)
      const width = Math.max(1, Math.floor(rect.width));
      const height = Math.max(1, Math.floor(rect.height));

      // Skip if dimensions haven't changed or are too small
      if (width < 10 || height < 10) return;
      if (this.canvas.width === width && this.canvas.height === height) return;

      this.params.pointerSize = 4 / height;
      this.canvas.width = this.textureCanvas.width = width;
      this.canvas.height = this.textureCanvas.height = height;
      this.initFBOs();
      this.updateTextCanvas();
    }

    private setupEvents() {
      this.canvas.addEventListener('mousemove', (e) => {
        this.isPreview = false;
        const rect = this.canvas.getBoundingClientRect();
        this.updateMousePosition(e.clientX - rect.left, e.clientY - rect.top);
      });

      this.canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        this.isPreview = false;
        const rect = this.canvas.getBoundingClientRect();
        this.updateMousePosition(
          e.targetTouches[0].clientX - rect.left,
          e.targetTouches[0].clientY - rect.top
        );
      }, { passive: false });

      this.canvas.addEventListener('mouseleave', () => {
        // Smoothly transition back to preview mode
        // Reset pointer to center to avoid jump
        const rect = this.canvas.getBoundingClientRect();
        this.pointer.x = rect.width * 0.5;
        this.pointer.y = rect.height * 0.5;
        this.pointer.dx = 0;
        this.pointer.dy = 0;
        this.pointer.moved = false;
        this.isPreview = true;
      });
    }

    private updateMousePosition(eX: number, eY: number) {
      this.pointer.moved = true;
      // Clamp delta to prevent crazy jumps
      const rawDx = eX - this.pointer.x;
      const rawDy = eY - this.pointer.y;
      this.pointer.dx = Math.max(-50, Math.min(50, 5 * rawDx));
      this.pointer.dy = Math.max(-50, Math.min(50, 5 * rawDy));
      this.pointer.x = eX;
      this.pointer.y = eY;
    }

    destroy() {
      this.isDestroyed = true;
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
      }
      window.removeEventListener('resize', this.handleResize);
    }
  }

  // Initialize all fluid text components
  function initFluidTexts() {
    document.querySelectorAll('[data-fluid-text]').forEach((container) => {
      if (!(container as any)._fluidSimulation) {
        (container as any)._fluidSimulation = new FluidSimulation(container as HTMLElement);
      }
    });
  }

  if (typeof window !== 'undefined') {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initFluidTexts);
    } else {
      initFluidTexts();
    }
  }
</script>

<style>
  .fluid-text-container {
    position: relative;
    width: 100%;
    height: 100%;
    min-height: 300px;
  }

  .fluid-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
</style>
