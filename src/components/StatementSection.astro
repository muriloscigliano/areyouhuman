---
// Statement Section with DotsGrid and PixelWorld backgrounds
// import DotsGrid from './DotsGrid.astro';
// import PixelWorld from './PixelWorld.astro';
---

<section class="statement-section" data-name="Statement Section" data-statement-section data-momentum-hover-init>
  <!-- PixelWorld shader background (bottom layer) -->
  <!-- <PixelWorld
    pixelSize={30}
    opacity={0.5}
    speed={0.5}
    staggerMode="center"
  /> -->
  <!-- DotsGrid on top of PixelWorld -->
  <!-- <DotsGrid
    dotColor="255, 255, 255"
    dotSize={2}
    spacing={50}
    maxDistance={120}
    pushStrength={35}
    baseOpacity={0.25}
  /> -->
  <div class="statement-inner">
    <ul data-momentum-hover-element>
      <li class="statement-line" data-text="Humanity"></li>
      <li class="statement-line" data-text="Amplified"></li>
    </ul>
  </div>
</section>

<script>
  // =============================================
  // BLUR ENTRANCE ANIMATION (like Hero)
  // =============================================
  async function initBlurEntrance() {
    const section = document.querySelector('[data-statement-section]');
    if (!section) {
      console.error('StatementSection: Section not found');
      return;
    }

    const lines = section.querySelectorAll('.statement-line');
    if (lines.length === 0) {
      console.error('StatementSection: Statement lines not found');
      return;
    }

    // First, create all the character spans from data-text attribute
    const allChars: HTMLElement[] = [];

    lines.forEach((line) => {
      const text = (line as HTMLElement).dataset.text || '';

      text.split('').forEach((char) => {
        const span = document.createElement('span');
        span.className = 'letter';
        span.textContent = char;
        // Add momentum hover target attribute for the hover effect
        span.setAttribute('data-momentum-hover-target', '');
        line.appendChild(span);
        allChars.push(span);
      });
    });

    if (allChars.length === 0) {
      console.error('StatementSection: No characters created');
      return;
    }

    console.log('StatementSection: Created', allChars.length, 'character spans');

    // Now load GSAP and animate
    const [{ gsap }, { default: ScrollTrigger }] = await Promise.all([
      import('gsap'),
      // @ts-ignore
      import('gsap/ScrollTrigger.js')
    ]);

    gsap.registerPlugin(ScrollTrigger);

    // Set initial state - letters start hidden via CSS, GSAP sets blur/transform
    // Like Hero: come from left with blur
    gsap.set(allChars, {
      opacity: 0,
      filter: 'blur(60px)',
      x: -100,
      scale: 1
    });

    console.log('StatementSection: Initial GSAP state set');

    // Function to animate the letters in
    const animateIn = () => {
      console.log('StatementSection: Animating in now!');

      // Trigger the DotsGrid animation at the same time
      const dotsCanvas = section.querySelector('[data-dots-grid]');
      if (dotsCanvas) {
        dotsCanvas.dispatchEvent(new CustomEvent('dots-grid-start'));
        console.log('StatementSection: Triggered DotsGrid animation');
      }

      gsap.to(allChars, {
        opacity: 1,
        filter: 'blur(0px)',
        x: 0,
        y: 0,
        scale: 1,
        duration: 1.0,
        ease: 'power3.out',
        stagger: {
          each: 0.06,
          from: 'start'
        },
        onComplete: () => {
          // Initialize momentum hover after entrance animation completes
          initMomentumHover(section as HTMLElement, allChars, gsap);
        }
      });
    };

    // Use Intersection Observer to trigger animation when section is visible
    // threshold: 0.5 means 50% of the section must be visible before triggering
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            console.log('StatementSection: Section is now visible via IntersectionObserver');
            animateIn();
            observer.disconnect(); // Only trigger once
          }
        });
      },
      { threshold: 0.5 }
    );

    observer.observe(section);
    console.log('StatementSection: IntersectionObserver set up');
  }

  // =============================================
  // MOMENTUM HOVER EFFECT
  // Letters react to mouse movement with GSAP InertiaPlugin
  // =============================================
  async function initMomentumHover(section: HTMLElement, letters: HTMLElement[], gsap: any) {
    // Only enable on hover-capable devices with fine pointer
    if (!window.matchMedia('(hover: hover) and (pointer: fine)').matches) {
      console.log('StatementSection: Momentum hover disabled (touch/coarse device)');
      return;
    }

    // Load InertiaPlugin
    // @ts-ignore
    const { InertiaPlugin } = await import('gsap/InertiaPlugin');
    gsap.registerPlugin(InertiaPlugin);

    console.log('StatementSection: Initializing momentum hover with InertiaPlugin');

    // Configuration (tweak these for feel)
    const xyMultiplier = 30; // multiplies pointer velocity for x/y movement
    const rotationMultiplier = 20; // multiplies normalized torque for rotation speed
    const inertiaResistance = 200; // higher = stops sooner

    // Pre-build clamp functions
    const clampXY = gsap.utils.clamp(-1080, 1080);
    const clampRot = gsap.utils.clamp(-60, 60);

    // Track pointer velocity at the section level
    let prevX = 0, prevY = 0;
    let velX = 0, velY = 0;
    let rafId: number | null = null;

    // Track velocity via mousemove (throttled to RAF)
    section.addEventListener('mousemove', (e: MouseEvent) => {
      if (rafId) return;
      rafId = requestAnimationFrame(() => {
        velX = e.clientX - prevX;
        velY = e.clientY - prevY;
        prevX = e.clientX;
        prevY = e.clientY;
        rafId = null;
      });
    });

    // Each letter triggers inertia on mouseenter
    letters.forEach((letter) => {
      letter.addEventListener('mouseenter', (e: MouseEvent) => {
        // Compute offset from center to pointer
        const rect = letter.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const offsetX = e.clientX - centerX;
        const offsetY = e.clientY - centerY;

        // Compute raw torque (px²/frame)
        const rawTorque = offsetX * velY - offsetY * velX;

        // Normalize torque so rotation ∝ pointer speed
        const leverDist = Math.hypot(offsetX, offsetY) || 1;
        const angularForce = rawTorque / leverDist;

        // Calculate and clamp velocities
        const velocityX = clampXY(velX * xyMultiplier);
        const velocityY = clampXY(velY * xyMultiplier);
        const rotationVelocity = clampRot(angularForce * rotationMultiplier);

        // Apply GSAP inertia tween
        gsap.to(letter, {
          inertia: {
            x: { velocity: velocityX, end: 0 },
            y: { velocity: velocityY, end: 0 },
            rotation: { velocity: rotationVelocity, end: 0 },
            resistance: inertiaResistance
          }
        });
      });
    });

    console.log('StatementSection: Momentum hover initialized on', letters.length, 'letters');
  }

  // =============================================
  // LETTER SCRAMBLE ANIMATION (disabled for now)
  // =============================================
  /*
  async function initStatementAnimation() {
    const section = document.querySelector('[data-statement-section]');
    if (!section) return;

    const [{ gsap }, { default: ScrollTrigger }] = await Promise.all([
      import('gsap'),
      // @ts-ignore
      import('gsap/ScrollTrigger.js')
    ]);

    gsap.registerPlugin(ScrollTrigger);

    const ulElement = section.querySelector('ul');
    const letterElements = section.querySelectorAll('.letter');

    if (!ulElement || letterElements.length === 0) {
      console.error('StatementSection: Elements not found');
      return;
    }

    gsap.to(letterElements, {
      yPercent: 100,
      ease: 'power1.inOut',
      scrollTrigger: {
        trigger: ulElement,
        start: '33.33% bottom',
        end: '100% 80%',
        scrub: 1,
        invalidateOnRefresh: true,
      },
      stagger: {
        each: 0.05,
        from: 'random'
      }
    });

    setTimeout(() => {
      ScrollTrigger.refresh();
    }, 100);
  }
  */

  // Initialize blur entrance animation
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(initBlurEntrance, 300);
    });
  } else {
    setTimeout(initBlurEntrance, 300);
  }
</script>

<style>
  .statement-section {
    padding: 0;
    position: relative;
    overflow: hidden;
    background-color: #000;
  }

  .statement-inner {
    padding: 50vh 48px;
    width: 100%;
    min-height: 100%;
    background-color: transparent;
    will-change: transform;
    position: relative;
    overflow: visible;
    z-index: 2;
  }

  .statement-section ul {
    display: flex;
    flex-direction: column;
    align-items: center;
    list-style: none;
    padding: 0;
    margin: 0;
    gap: 0;
    position: relative;
    z-index: 3;
  }

  .statement-section li,
  .statement-line {
    font-family: 'PP Neue Machina', sans-serif;
    font-weight: 800;
    font-size: clamp(86px, 12vw, 300px);
    line-height: 0.95;
    color: #fff;
    text-transform: uppercase;
    display: flex;
    position: relative;
  }

  /* Letters start hidden - like Hero's .title-char { opacity: 0 } */
  .statement-section .letter {
    display: inline-block;
    opacity: 0;
    will-change: transform, filter, opacity;
  }

  @media (max-width: 768px) {
    .statement-section li {
      font-size: clamp(60px, 15vw, 86px);
    }
  }
</style>
