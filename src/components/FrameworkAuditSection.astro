---
const steps = [
  {
    number: '01',
    label: 'Discover',
    title: 'Humanity Audit',
    description: `Benchmark your Human Advantage Score (0â€“100).
Compare against human-first leaders in your industry.
Identify highest-risk areas for human value loss.`,
    image: 'https://cdn.prod.website-files.com/68b83c9a431270d8deb1e6b1/68b847956497fe87b81b7025_Iced%20Matcha%20Latte.avif'
  },
  {
    number: '02',
    label: 'Design',
    title: 'Design for humanity',
    description: `Selecting the best-fit third-party AI tools
Designing human-first experiences with cognitive and emotional design
Transforming intelligence into meaningful human advantage`,
    image: 'https://cdn.prod.website-files.com/68b83c9a431270d8deb1e6b1/68b847956468e74ee70e259e_Matcha%20Whisking%20Art.avif'
  },
  {
    number: '03',
    label: 'Deploy',
    title: 'Human-Centered Deployment',
    description: `Staging releases with deliberate human checkpoints
Empowering teams to build trust and confidence in AI
Driving adoption through clarity, training, and purpose`,
    image: 'https://cdn.prod.website-files.com/68b83c9a431270d8deb1e6b1/68b84795dd49cb5a5f2a2640_Steaming%20Orange%20Beverage.avif'
  },
  {
    number: '04',
    label: 'Defend',
    title: 'Humanity Safeguard',
    description: `Quarterly "humanity health checks."
AI evolution tracking and rebalancing.
Access to the Human-First Leaders Network.`,
    image: 'https://cdn.prod.website-files.com/68b83c9a431270d8deb1e6b1/68b8479522525b321756af2e_Hands%20Holding%20Matcha%20Cup.avif'
  }
];
---

<div data-framework-section class="framework-section">

  <div class="framework-container">
    <!-- Image Column -->
    <div class="framework-col framework-col--img">
      <div class="framework-images">
        {steps.map((step) => (
          <div data-framework-img class="framework-img-item">
            <img src={step.image} alt={step.title} />
          </div>
        ))}
      </div>
      <div class="framework-progress">
        <div data-framework-progress class="framework-progress-bar"></div>
      </div>
    </div>

    <!-- Text Column -->
    <div class="framework-col framework-col--text">
      <div class="framework-text-list">
        {steps.map((step) => (
          <div data-framework-item class="framework-item">
            <div class="framework-header">
              <p class="framework-number">{step.number}</p>
              <p class="framework-label">{step.label}</p>
            </div>
            <h2 class="framework-title">{step.title}</h2>
            <p class="framework-description">{step.description}</p>
          </div>
        ))}
      </div>
    </div>
  </div>
</div>

<script>
  import { gsap } from 'gsap';

  // Plugin cache
  let ScrollTrigger: any = null;
  let ScrambleTextPlugin: any = null;
  let SplitText: any = null;

  // Store original text content and split instances
  const originalTexts = new Map<Element, string>();
  const splitInstances = new Map<Element, any>();

  async function loadPlugins() {
    if (typeof window === 'undefined') return false;

    try {
      if (!ScrollTrigger) {
        const stModule = await import('gsap/ScrollTrigger.js');
        ScrollTrigger = stModule.default;
        gsap.registerPlugin(ScrollTrigger);
      }

      if (!ScrambleTextPlugin) {
        try {
          const scrambleModule = await import('gsap/ScrambleTextPlugin');
          ScrambleTextPlugin = scrambleModule.default || scrambleModule.ScrambleTextPlugin;
          if (ScrambleTextPlugin) {
            gsap.registerPlugin(ScrambleTextPlugin);
            console.log('FrameworkAuditSection: ScrambleTextPlugin loaded successfully');
          }
        } catch (e) {
          console.error('FrameworkAuditSection: Failed to load ScrambleTextPlugin', e);
        }
      }

      if (!SplitText) {
        try {
          const splitModule = await import('gsap/SplitText');
          SplitText = splitModule.default || splitModule.SplitText;
          if (SplitText) {
            gsap.registerPlugin(SplitText);
            console.log('FrameworkAuditSection: SplitText loaded successfully');
          }
        } catch (e) {
          console.error('FrameworkAuditSection: Failed to load SplitText', e);
        }
      }

      return true;
    } catch (error) {
      console.error('FrameworkAuditSection: Failed to load plugins', error);
      return false;
    }
  }

  function animateTextIn(item: Element) {
    const elements = item.querySelectorAll('.framework-number, .framework-label, .framework-title, .framework-description');

    // Show the item container
    gsap.set(item, { autoAlpha: 1 });

    // If we have SplitText and ScrambleText, use the proper scramble effect
    if (SplitText && ScrambleTextPlugin) {
      elements.forEach((el, i) => {
        // Restore original text first if we have it stored
        if (originalTexts.has(el)) {
          el.textContent = originalTexts.get(el)!;
        } else {
          // Store original text on first run
          originalTexts.set(el, el.textContent || '');
        }

        // Revert any existing split
        if (splitInstances.has(el)) {
          splitInstances.get(el).revert();
          splitInstances.delete(el);
        }

        // Create new split
        const split = new SplitText(el, {
          type: 'words, chars',
          wordsClass: 'word',
          charsClass: 'char'
        });
        splitInstances.set(el, split);

        // Animate with scramble - using {original} to reveal to original text
        gsap.to(split.words, {
          duration: 1.0,
          delay: i * 0.08,
          stagger: 0.015,
          scrambleText: {
            text: '{original}',
            chars: 'upperCase',
            speed: 0.8
          },
          onComplete: () => {
            // Revert split after animation to clean up DOM
            split.revert();
            splitInstances.delete(el);
          }
        });
      });
    } else {
      // Fallback: simple fade
      gsap.fromTo(elements,
        { autoAlpha: 0 },
        { autoAlpha: 1, duration: 0.4, stagger: 0.08 }
      );
    }
  }

  function animateTextOut(item: Element) {
    const elements = item.querySelectorAll('.framework-number, .framework-label, .framework-title, .framework-description');

    // Kill any running animations
    gsap.killTweensOf(item);
    elements.forEach(el => {
      gsap.killTweensOf(el);
      // Kill animations on words/chars too
      el.querySelectorAll('.word, .char').forEach(w => gsap.killTweensOf(w));

      // Revert any split instances
      if (splitInstances.has(el)) {
        splitInstances.get(el).revert();
        splitInstances.delete(el);
      }
    });

    // Hide immediately
    gsap.set(item, { autoAlpha: 0 });
  }

  async function init() {
    const section = document.querySelector('[data-framework-section]');
    if (!section) return;

    // Wait for intro animation
    const mainContent = document.getElementById('main-content');
    if (mainContent?.classList.contains('landing--hidden')) {
      await new Promise<void>(resolve => {
        window.addEventListener('intro-complete', () => setTimeout(resolve, 500), { once: true });
      });
    }

    // Load plugins
    const loaded = await loadPlugins();
    if (!loaded || !ScrollTrigger) return;

    // Get elements
    const images = section.querySelectorAll('[data-framework-img]');
    const items = section.querySelectorAll('[data-framework-item]');
    const progressBar = section.querySelector('[data-framework-progress]');

    if (images.length !== items.length || items.length === 0) return;

    const count = items.length;
    const reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const DURATION = reducedMotion ? 0.01 : 0.6;

    // Store all original text content first (before any animations)
    items.forEach(item => {
      const elements = item.querySelectorAll('.framework-number, .framework-label, .framework-title, .framework-description');
      elements.forEach(el => {
        if (!originalTexts.has(el)) {
          originalTexts.set(el, el.textContent || '');
        }
      });
    });

    // Set initial states - first item visible, rest hidden
    gsap.set(images[0], { clipPath: 'inset(0% round 12px)' });
    gsap.set(items[0], { autoAlpha: 1 });

    // Set other items to hidden state
    for (let i = 1; i < count; i++) {
      gsap.set(items[i], { autoAlpha: 0 });
    }

    let currentIndex = 0;

    function transition(from: number, to: number) {
      if (from === to) return;

      // Image transition
      if (from < to) {
        gsap.to(images[to], { clipPath: 'inset(0% round 12px)', duration: DURATION, ease: 'power3.inOut' });
      } else {
        gsap.to(images[from], { clipPath: 'inset(50% round 12px)', duration: DURATION, ease: 'power3.inOut' });
      }

      // Text transition
      animateTextOut(items[from]);
      animateTextIn(items[to]);
    }

    // Create ScrollTrigger
    ScrollTrigger.create({
      trigger: section,
      start: 'top top',
      end: `+=${(count - 1) * 100}%`,
      pin: true,
      scrub: true,
      onUpdate: (self: any) => {
        const progress = Math.min(self.progress, 0.9) / 0.9;
        const idx = Math.min(Math.floor(progress * (count - 1) + 0.001), count - 1);

        // Update progress bar
        if (progressBar) {
          gsap.to(progressBar, { scaleX: progress, duration: 0.1 });
        }

        // Trigger transition
        if (idx !== currentIndex) {
          transition(currentIndex, idx);
          currentIndex = idx;
        }
      }
    });

    // Refresh after setup
    setTimeout(() => ScrollTrigger.refresh(), 500);
  }

  // Initialize
  if (typeof window !== 'undefined') {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }

    // Handle resize
    let resizeTimer: ReturnType<typeof setTimeout>;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => ScrollTrigger?.refresh(), 200);
    });
  }
</script>

<style>
  .framework-section {
    width: 100%;
    padding: 48px;
    background: #000;
    min-height: 100vh;
    position: relative;
    overflow: hidden;
  }

  .framework-container {
    display: flex;
    gap: 18px;
    height: 100vh;
    width: 100%;
    position: relative;
    z-index: 2;
  }

  .framework-col {
    min-width: 0;
    min-height: 0;
    background: #0f0f0f;
    border-radius: 12px;
  }

  .framework-col--img {
    flex: 1;
    position: relative;
    overflow: hidden;
  }

  .framework-col--text {
    width: 50%;
    padding: 128px 72px;
    display: flex;
    flex-direction: column;
    justify-content: center;
  }

  /* Images */
  .framework-images {
    width: 100%;
    height: 100%;
    position: relative;
  }

  .framework-img-item {
    position: absolute;
    inset: 0;
    clip-path: inset(50% round 12px);
  }

  .framework-img-item:first-child {
    clip-path: inset(0% round 12px);
  }

  .framework-img-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 12px;
  }

  /* Progress bar */
  .framework-progress {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: rgba(255, 255, 255, 0.15);
    z-index: 10;
  }

  .framework-progress-bar {
    width: 100%;
    height: 100%;
    background: #fff;
    transform: scaleX(0);
    transform-origin: left;
  }

  /* Text items */
  .framework-text-list {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
  }

  .framework-item {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    opacity: 0;
    visibility: hidden;
  }

  .framework-item:first-child {
    opacity: 1;
    visibility: visible;
  }

  .framework-header {
    display: flex;
    flex-direction: column;
    gap: 10px;
    font-family: 'PP Neue Machina', sans-serif;
    font-weight: 400;
    font-size: 32px;
    line-height: 0.9;
    color: #fff;
    text-transform: uppercase;
  }

  .framework-number,
  .framework-label {
    margin: 0;
  }

  .framework-title {
    margin: 0;
    font-family: 'PP Neue Machina', sans-serif;
    font-weight: 800;
    font-size: clamp(56px, 8vw, 80px);
    line-height: 0.9;
    color: #fff;
    text-transform: uppercase;
    word-wrap: break-word;
  }

  .framework-item:last-child .framework-title {
    font-size: clamp(48px, 7vw, 56px);
  }

  .framework-description {
    margin: 0;
    font-family: 'PP Supply Mono', monospace;
    font-weight: 200;
    font-size: clamp(16px, 2vw, 18px);
    line-height: 1.5;
    color: #fff;
    white-space: pre-line;
    max-width: 600px;
  }

  /* SplitText word/char styles - inherit all font properties */
  .framework-item .word,
  .framework-item .char {
    display: inline-block;
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    line-height: inherit;
    text-transform: inherit;
    color: inherit;
  }

  .framework-item .word {
    white-space: pre;
  }

  /* Mobile */
  @media (max-width: 767px) {
    .framework-section {
      padding: 24px;
    }

    .framework-container {
      flex-direction: column;
      gap: 24px;
      height: auto;
      min-height: 100svh;
      padding: 24px 0;
    }

    .framework-col--img {
      aspect-ratio: 1;
      flex: none;
    }

    .framework-col--text {
      width: 100%;
      padding: 48px 24px;
      min-height: 300px;
    }

    .framework-header {
      font-size: 24px;
    }

    .framework-title {
      font-size: 48px;
    }

    .framework-description {
      font-size: 16px;
    }
  }
</style>
