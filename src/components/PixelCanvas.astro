---
interface Props {
  colors?: string;
  gap?: number;
  speed?: number;
  shimmerIntensity?: number;
  noFocus?: boolean;
  disabled?: boolean;
  triggerSelector?: string;
  debug?: boolean;
  class?: string;
}

const {
  colors = '#f8fafc,#f1f5f9,#cbd5e1',
  gap = 5,
  speed = 35,
  shimmerIntensity = 0.3,
  noFocus = false,
  disabled = false,
  triggerSelector = '',
  debug = false,
  class: className = '',
} = Astro.props;
---

{!disabled && (
  <div class={`pixel-canvas-container ${className}`} data-pixel-canvas>
    <pixel-canvas
      data-colors={colors}
      data-gap={gap.toString()}
      data-speed={speed.toString()}
      data-shimmer-intensity={shimmerIntensity.toString()}
      data-no-focus={noFocus ? '' : undefined}
      data-debug={debug ? '' : undefined}
      data-trigger-selector={triggerSelector}
    />
  </div>
)}

<script>
  // Define Pixel class
  class Pixel {
    constructor(canvas, context, x, y, color, speed, delay, shimmerIntensity = 0.5) {
      this.width = canvas.width;
      this.height = canvas.height;
      this.ctx = context;
      this.x = x;
      this.y = y;
      this.color = color;
      this.speed = this.getRandomValue(0.1, 0.9) * speed;
      this.size = 0;
      this.sizeStep = Math.random() * 0.4;
      this.minSize = 0.5;
      this.maxSizeInteger = 2;
      this.maxSize = this.getRandomValue(this.minSize, this.maxSizeInteger);
      this.delay = delay;
      this.counter = 0;
      this.counterStep = Math.random() * 4 + (this.width + this.height) * 0.01;
      this.isIdle = false;
      this.isReverse = false;
      this.isShimmer = false;
      this.shimmerIntensity = shimmerIntensity;
    }

    getRandomValue(min, max) {
      return Math.random() * (max - min) + min;
    }

    draw() {
      const centerOffset = this.maxSizeInteger * 0.5 - this.size * 0.5;
      this.ctx.fillStyle = this.color;
      this.ctx.fillRect(
        this.x + centerOffset,
        this.y + centerOffset,
        this.size,
        this.size
      );
    }

    appear() {
      this.isIdle = false;
      if (this.counter <= this.delay) {
        this.counter += this.counterStep;
        return;
      }
      if (this.size >= this.maxSize) {
        this.isShimmer = true;
      }
      if (this.isShimmer) {
        this.shimmer();
      } else {
        this.size += this.sizeStep;
      }
      this.draw();
    }

    disappear() {
      this.isShimmer = false;
      this.counter = 0;
      if (this.size <= 0) {
        this.isIdle = true;
        return;
      } else {
        this.size -= 0.1;
      }
      this.draw();
    }

    shimmer() {
      const shimmerMinSize = this.maxSize * (1 - this.shimmerIntensity);

      if (this.size >= this.maxSize) {
        this.isReverse = true;
      } else if (this.size <= shimmerMinSize) {
        this.isReverse = false;
      }
      if (this.isReverse) {
        this.size -= this.speed;
      } else {
        this.size += this.speed;
      }
      this.draw();
    }
  }

  // Define PixelCanvas Custom Element
  class PixelCanvas extends HTMLElement {
    static register(tag = "pixel-canvas") {
      if ("customElements" in window && !customElements.get(tag)) {
        customElements.define(tag, PixelCanvas);
      }
    }

    static css = `
      :host {
        display: block;
        width: 100%;
        height: 100%;
        overflow: hidden;
        position: absolute;
        top: 0;
        left: 0;
        will-change: auto;
      }
      canvas {
        display: block;
        width: 100%;
        height: 100%;
        will-change: contents;
      }
    `;

    get colors() {
      return this.dataset.colors?.split(",") || ["#f8fafc", "#f1f5f9", "#cbd5e1"];
    }

    get gap() {
      const value = this.dataset.gap || 5;
      const min = 4;
      const max = 50;
      if (value <= min) {
        return min;
      } else if (value >= max) {
        return max;
      } else {
        return parseInt(value);
      }
    }

    get speed() {
      const value = this.dataset.speed || 35;
      const min = 0;
      const max = 100;
      const throttle = 0.001;
      if (value <= min || this.reducedMotion) {
        return min;
      } else if (value >= max) {
        return max * throttle;
      } else {
        return parseInt(value) * throttle;
      }
    }

    get noFocus() {
      return this.hasAttribute("data-no-focus");
    }

    get shimmerIntensity() {
      const value = parseFloat(this.dataset.shimmerIntensity) || 0.5;
      return Math.max(0, Math.min(1, value));
    }

    get triggerSelector() {
      return this.dataset.triggerSelector || '';
    }

    connectedCallback() {
      const debug = this.hasAttribute('data-debug');
      if (debug) console.log('PixelCanvas: connectedCallback called');

      this._parent = this.parentNode;

      // Force explicit dimensions
      this.style.display = 'block';
      this.style.position = 'absolute';
      this.style.top = '0';
      this.style.left = '0';
      this.style.right = '0';
      this.style.bottom = '0';
      this.style.width = '100%';
      this.style.height = '100%';

      const canvas = document.createElement("canvas");
      const sheet = new CSSStyleSheet();
      this.shadowroot = this.attachShadow({ mode: "open" });
      sheet.replaceSync(PixelCanvas.css);
      this.shadowroot.adoptedStyleSheets = [sheet];
      this.shadowroot.append(canvas);
      this.canvas = this.shadowroot.querySelector("canvas");
      this.ctx = this.canvas.getContext("2d", { willReadFrequently: true });
      this.timeInterval = 1000 / 45; // 45fps
      this.timePrevious = performance.now();
      this.reducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;

      const initialize = () => {
        const parentRect = this._parent?.getBoundingClientRect();
        const rect = this.getBoundingClientRect();

        let width, height;

        if (parentRect && parentRect.width > 0 && parentRect.height > 0) {
          width = Math.floor(parentRect.width);
          height = Math.floor(parentRect.height);
        } else if (rect.width > 0 && rect.height > 0) {
          width = Math.floor(rect.width);
          height = Math.floor(rect.height);
        } else {
          width = window.innerWidth;
          height = window.innerHeight;
          this.style.width = `${width}px`;
          this.style.height = `${height}px`;
        }

        if (debug) console.log('PixelCanvas: Initializing with dimensions', { width, height });

        if (width > 0 && height > 0) {
          this.init();
        } else {
          console.warn('PixelCanvas: Still no dimensions, retrying...');
          setTimeout(initialize, 100);
        }
      };

      requestAnimationFrame(() => {
        setTimeout(initialize, 50);
      });

      this.resizeObserver = new ResizeObserver(() => {
        setTimeout(() => {
          if (this.animation) {
            cancelAnimationFrame(this.animation);
            this.animation = null;
          }
          initialize();
        }, 10);
      });
      this.resizeObserver.observe(this);
    }

    disconnectedCallback() {
      this.resizeObserver?.disconnect();
      if (this.animation) {
        cancelAnimationFrame(this.animation);
        this.animation = null;
      }
      delete this._parent;
    }

    init() {
      const parentRect = this._parent?.getBoundingClientRect();
      const rect = this.getBoundingClientRect();

      let width, height;

      if (parentRect && parentRect.width > 0 && parentRect.height > 0) {
        width = Math.floor(parentRect.width);
        height = Math.floor(parentRect.height);
      } else if (rect.width > 0 && rect.height > 0) {
        width = Math.floor(rect.width);
        height = Math.floor(rect.height);
      } else {
        width = window.innerWidth;
        height = window.innerHeight;
      }

      const debug = this.hasAttribute('data-debug');
      if (debug) console.log('PixelCanvas: init() called with dimensions:', { width, height });

      if (width === 0 || height === 0) {
        if (debug) console.warn('PixelCanvas: Skipping init - no dimensions');
        return;
      }

      this.pixels = [];
      this.canvas.width = width;
      this.canvas.height = height;
      this.canvas.style.width = `${width}px`;
      this.canvas.style.height = `${height}px`;
      this.canvas.style.display = 'block';
      this.canvas.style.position = 'absolute';
      this.canvas.style.top = '0';
      this.canvas.style.left = '0';

      this.createPixels();
      if (debug) console.log('PixelCanvas: Created', this.pixels.length, 'pixels');

      if (this.pixels.length > 0) {
        this.ctx.clearRect(0, 0, width, height);

        this.pixels.forEach(pixel => {
          pixel.size = 0;
          pixel.isShimmer = false;
          pixel.isIdle = true;
          pixel.counter = 0;
        });

        if (debug) console.log('PixelCanvas: Pixels initialized for entrance animation');
      } else {
        console.error('PixelCanvas: No pixels created!', { width, height, gap: this.gap });
      }
    }

    getDistanceToCanvasCenter(x, y) {
      const dx = x - this.canvas.width / 2;
      const dy = y - this.canvas.height / 2;
      return Math.sqrt(dx * dx + dy * dy);
    }

    createPixels() {
      for (let x = 0; x < this.canvas.width; x += this.gap) {
        for (let y = 0; y < this.canvas.height; y += this.gap) {
          const color = this.colors[Math.floor(Math.random() * this.colors.length)];
          const delay = this.reducedMotion ? 0 : this.getDistanceToCanvasCenter(x, y);
          this.pixels.push(
            new Pixel(this.canvas, this.ctx, x, y, color, this.speed, delay, this.shimmerIntensity)
          );
        }
      }
    }

    animate(fnName) {
      this.animation = requestAnimationFrame(() => this.animate(fnName));

      if (!this.pixels || this.pixels.length === 0) {
        const debug = this.hasAttribute('data-debug');
        if (debug) console.warn('PixelCanvas: No pixels to animate');
        cancelAnimationFrame(this.animation);
        return;
      }

      const timeNow = performance.now();
      const timePassed = timeNow - this.timePrevious;
      if (timePassed < this.timeInterval) return;
      this.timePrevious = timeNow - (timePassed % this.timeInterval);
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      for (let i = 0; i < this.pixels.length; i++) {
        this.pixels[i][fnName]();
      }
    }

    handleAnimation(name) {
      cancelAnimationFrame(this.animation);
      this.animation = this.animate(name);
    }
  }

  // Register custom element
  if (typeof window !== 'undefined' && 'customElements' in window) {
    PixelCanvas.register();
  }

  // Setup ScrollTrigger animation for all pixel canvas instances
  async function setupPixelCanvasAnimations() {
    const containers = document.querySelectorAll('[data-pixel-canvas]');
    if (containers.length === 0) return;

    // Lazy load GSAP ScrollTrigger
    const { default: ScrollTrigger } = await import('gsap/ScrollTrigger');
    const { gsap } = await import('gsap');
    gsap.registerPlugin(ScrollTrigger);

    containers.forEach(container => {
      const pixelCanvasElement = container.querySelector('pixel-canvas');
      if (!pixelCanvasElement) return;

      const debug = pixelCanvasElement.hasAttribute('data-debug');
      const triggerSelector = pixelCanvasElement.dataset.triggerSelector;

      // Find parent section
      let parentSection;
      if (triggerSelector) {
        parentSection = container.closest(triggerSelector);
      }
      if (!parentSection) {
        parentSection = container.closest('.statement-section');
      }
      if (!parentSection) {
        parentSection = container.closest('section');
      }

      if (!parentSection) {
        if (debug) console.warn('PixelCanvas: Parent section not found');
        return;
      }

      if (debug) console.log('PixelCanvas: Using trigger section:', parentSection.className || parentSection.tagName);

      let appearAnimationFrame = null;
      let hasTriggered = false;

      const runAppearAnimation = () => {
        if (hasTriggered) return;
        hasTriggered = true;

        if (!pixelCanvasElement.pixels || !pixelCanvasElement.ctx) {
          if (debug) console.warn('PixelCanvas: Cannot run appear animation - element not ready');
          return;
        }

        if (debug) console.log('PixelCanvas: Starting appear animation');

        if (appearAnimationFrame) {
          cancelAnimationFrame(appearAnimationFrame);
        }
        if (pixelCanvasElement.animation) {
          cancelAnimationFrame(pixelCanvasElement.animation);
          pixelCanvasElement.animation = null;
        }

        pixelCanvasElement.pixels.forEach(pixel => {
          pixel.size = 0;
          pixel.isShimmer = false;
          pixel.isIdle = true;
          pixel.counter = 0;
        });

        const animateAppear = () => {
          if (!pixelCanvasElement.pixels) return;

          pixelCanvasElement.ctx.clearRect(0, 0, pixelCanvasElement.canvas.width, pixelCanvasElement.canvas.height);

          let allDone = true;
          pixelCanvasElement.pixels.forEach(pixel => {
            pixel.appear();
            if (!pixel.isShimmer) {
              allDone = false;
            }
          });

          if (!allDone) {
            appearAnimationFrame = requestAnimationFrame(animateAppear);
          } else {
            if (debug) console.log('PixelCanvas: All pixels appeared, starting shimmer');
            appearAnimationFrame = null;

            pixelCanvasElement.pixels.forEach(pixel => {
              pixel.isShimmer = true;
            });

            if (typeof pixelCanvasElement.handleAnimation === 'function') {
              pixelCanvasElement.handleAnimation('shimmer');
            }
          }
        };

        animateAppear();
      };

      const checkInView = () => {
        const rect = parentSection.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        return rect.top < viewportHeight * 0.7 && rect.bottom > 0;
      };

      ScrollTrigger.create({
        trigger: parentSection,
        start: 'top 70%',
        once: true,
        onEnter: () => {
          if (debug) console.log('PixelCanvas: ScrollTrigger onEnter fired');
          runAppearAnimation();
        }
      });

      if (checkInView()) {
        if (debug) console.log('PixelCanvas: Already in view, triggering immediately');
        setTimeout(() => {
          runAppearAnimation();
        }, 300);
      }

      if (debug) console.log('PixelCanvas: ScrollTrigger setup complete');
    });
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(setupPixelCanvasAnimations, 800);
    });
  } else {
    setTimeout(setupPixelCanvasAnimations, 800);
  }
</script>

<style>
  .pixel-canvas-container {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    pointer-events: none;
    z-index: 0;
  }

  .pixel-canvas-container :global(pixel-canvas) {
    display: block;
    width: 100%;
    height: 100%;
    pointer-events: auto;
  }
</style>
